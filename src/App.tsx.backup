  // ...existing code...
import React, { useEffect, useRef, useState } from "react";
import Sidebar from "./components/Sidebar";
import SearchBox from "./components/SearchBox";
import { usePdfDocument } from "./hooks/usePdfDocument";
import { openPdfFiles, savePdfFile, showInFolder } from "./lib/fileDialogs";
import { renderPageToCanvas, extractTextRects } from "./lib/pdfRender";
import { addInkPath, addTextBox, addHighlightRects, extractPages, insertBlankPage, mergePdfs, rotatePage } from "./lib/pdfWrite";
import type { OpenedFile } from "./lib/types";

// Icon SVGs for different tools
const IconSVGs = {
  cursor: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.121 2.122" />,
  hand: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11" />,
  text: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />,
  marker: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 4V2a1 1 0 011-1h8a1 1 0 011 1v2m0 0V1h-2m2 3v16l-7-3-7 3V7" />,
  pen: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />,
  signature: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />,
  rotate: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />,
  rotateLeft: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 20v-5h-.582m-15.356-2A8.001 8.001 0 0119.418 15m0 0H15m-11-11v5h.581m0 0a8.003 8.003 0 0115.357 2M4.581 9H9" />,
  rotateRight: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />,
  refresh: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />,
  extract: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />,
  ocr: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />,
  redact: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
};

// ToolButton component
const ToolButton = ({ icon, label, onClick }: { 
  icon: keyof typeof IconSVGs; 
  label: string; 
  onClick?: () => void;
}) => (
  <button
    onClick={onClick}
    className="flex items-center space-x-2 px-3 py-2 text-gray-700 hover:bg-white hover:shadow-sm rounded-lg transition-colors group"
    title={label}
  >
    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      {IconSVGs[icon]}
    </svg>
    <span className="text-sm">{label}</span>
  </button>
);

export default function App() {
  const [file, setFile] = useState<OpenedFile | undefined>(undefined);
  const [buffers, setBuffers] = useState<Uint8Array | null>(null);
  const { pdf, pageCount } = usePdfDocument(file);
  const [pageIndex, setPageIndex] = useState(0);
  const [zoom, setZoom] = useState(1);
  const [isFirstLoad, setIsFirstLoad] = useState(true);
  const [viewerDimensions, setViewerDimensions] = useState({ width: 0, height: 0 });
  const viewerRef = useRef<HTMLDivElement>(null);
  const [scrollMode, setScrollMode] = useState<'page' | 'continuous'>('page');
  
  // Input dialog states
  const [showTextDialog, setShowTextDialog] = useState(false);
  const [showHighlightDialog, setShowHighlightDialog] = useState(false);
  const [showRedactDialog, setShowRedactDialog] = useState(false);
  const [showMergeDialog, setShowMergeDialog] = useState(false);
  const [textInput, setTextInput] = useState("");
  const [highlightInput, setHighlightInput] = useState("");
  const [redactInput, setRedactInput] = useState("");
  const [mergeFiles, setMergeFiles] = useState<OpenedFile[]>([]);
  const [mergePosition, setMergePosition] = useState<'before' | 'after' | 'replace'>('after');

  // Buffer management state
  const [cachedBuffer, setCachedBuffer] = useState<Uint8Array | null>(null);

  // Notification state
  const [notification, setNotification] = useState<string | null>(null);

  // Show notification that auto-disappears
  const showNotification = (message: string) => {
    setNotification(message);
    setTimeout(() => setNotification(null), 3000);
  };

  // Utility function to get a working buffer, handling detachment
  const getWorkingBuffer = (): Uint8Array | null => {
    if (!buffers || !file) return null;
    
    // Use cached buffer if available and valid
    if (cachedBuffer) {
      try {
        cachedBuffer.slice(0, 1); // Test if cached buffer is detached
        return cachedBuffer;
      } catch (e) {
        console.log("Cached buffer is detached, clearing cache");
        setCachedBuffer(null);
      }
    }
    
    try {
      buffers.slice(0, 1); // Test if buffer is detached
      const safeCopy = createSafeBuffer(buffers);
      setCachedBuffer(safeCopy);
      return safeCopy;
    } catch (error) {
      console.warn("Main buffer is detached, trying file.data");
      
      if (file.data && file.data instanceof Uint8Array) {
        try {
          file.data.slice(0, 1); // Test if file.data is detached
          const safeCopy = createSafeBuffer(file.data);
          setCachedBuffer(safeCopy);
          return safeCopy;
        } catch (fileDataError) {
          console.error("Both buffers are detached");
          return null;
        }
      }
      return null;
    }
  };

  // Utility function to create a safe copy of a buffer
  const createSafeBuffer = (source: Uint8Array): Uint8Array => {
    try {
      // Always create a completely independent copy
      return new Uint8Array(source);
    } catch (e) {
      console.error("Cannot create safe buffer from source");
      throw new Error("Source buffer is corrupted");
    }
  };

  // Enhanced buffer update with immediate safe copy
  const updateBuffers = (newBuffer: Uint8Array) => {
    try {
      // Create a safe copy immediately before setting state
      const safeCopy = createSafeBuffer(newBuffer);
      setBuffers(safeCopy);
      setCachedBuffer(safeCopy);
      console.log("Buffers updated with safe copy, length:", safeCopy.length);
    } catch (error) {
      console.error("Failed to update buffers:", error);
    }
  };

  // Clear cached buffer when main buffer changes and ensure safe copies
  useEffect(() => {
    if (buffers) {
      try {
        // Test if buffer is accessible and update cache with fresh copy
        const testSlice = buffers.slice(0, 1);
        const freshCopy = new Uint8Array(buffers);
        setCachedBuffer(freshCopy);
        console.log("Cache updated with fresh buffer copy");
      } catch (e) {
        console.log("Buffer detached, keeping existing cache");
        // Don't clear cache if main buffer is detached
      }
    } else {
      setCachedBuffer(null);
    }
  }, [buffers]);

  // Handler for menu-open-pdf, defined after state so it can access setters
  const handleMenuOpenPdf = async (filePaths: string[]) => {
    try {
      console.log("Menu open PDF triggered with files:", filePaths);
      if (!filePaths || filePaths.length === 0) return;
      
      const arr = await Promise.all(filePaths.map(async (p) => {
        console.log("Reading file:", p);
        const data = await window.electronAPI?.readFileAsUint8Array(p);
        if (!data) {
          throw new Error(`Failed to read file: ${p}`);
        }
        const name = p.split(/[\\/]/).pop() || "Untitled.pdf";
        console.log("File read successfully:", name, "size:", data.length);
        return { name, path: p, data };
      }));
      
      if (arr.length === 1) {
        console.log("Setting single file:", arr[0].name);
        console.log("Buffer data length:", arr[0].data.length);
        console.log("Buffer data type:", typeof arr[0].data);
        console.log("Buffer is Uint8Array:", arr[0].data instanceof Uint8Array);
        const fileData = createSafeBuffer(arr[0].data);
        setFile({ ...arr[0], data: fileData });
        setBuffers(fileData);
        setPageIndex(0);
        setIsFirstLoad(true); // Reset first load flag for new file
        console.log("Buffers state should be set now");
      } else if (arr.length > 1) {
        console.log("Merging multiple files:", arr.length);
        const merged = await mergePdfs(arr.map(f => f.data).filter((data): data is Uint8Array => data !== undefined));
        const name = arr.map(f => f.name).join("+") + ".pdf";
        const mergedData = createSafeBuffer(merged);
        const combined: OpenedFile = { name, data: mergedData };
        setFile(combined);
        setBuffers(mergedData);
        setPageIndex(0);
        setIsFirstLoad(true); // Reset first load flag for new file
      }
    } catch (error) {
      console.error("Error in handleMenuOpenPdf:", error);
    }
  };

  useEffect(() => {
    // Only set up Electron IPC if we're in Electron
    if (!window.electronAPI || !window.electronAPI.ipcRenderer) {
      console.log("Running in browser mode - Electron APIs not available");
      return;
    }
    
    // Remove any existing listeners first to prevent memory leaks
    window.electronAPI.ipcRenderer.removeAllListeners("menu-open-pdf");
    
    // Add the listener
    window.electronAPI.ipcRenderer.on("menu-open-pdf", handleMenuOpenPdf);
    
    return () => {
      if (window.electronAPI && window.electronAPI.ipcRenderer) {
        window.electronAPI.ipcRenderer.removeAllListeners("menu-open-pdf");
      }
    };
  }, []);

  useEffect(() => {
    if (!pdf) return;
    setPageIndex(0);
  }, [pdf]);

  const open = async () => {
    // Check if we're in Electron or browser mode
    if (window.electronAPI) {
      // Electron mode - use native file dialogs
      const files = await openPdfFiles();
      if (!files || files.length === 0) return;
      if (files.length === 1) {
        setFile(files[0]);
        setBuffers(files[0].data);
        setPageIndex(0);
        setIsFirstLoad(true); // Reset first load flag for new file
      } else {
        const merged = await mergePdfs(files.map(f => f.data));
        const name = files.map(f => f.name).join("+") + ".pdf";
        const combined: OpenedFile = { name, data: merged };
        setFile(combined);
        setBuffers(merged);
        setPageIndex(0);
        setIsFirstLoad(true); // Reset first load flag for new file
      }
    } else {
      // Browser mode - use HTML file input
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".pdf";
      input.multiple = true;
      input.onchange = async (e) => {
        const fileList = (e.target as HTMLInputElement).files;
        if (!fileList || fileList.length === 0) return;
        
        const files: OpenedFile[] = [];
        for (let i = 0; i < fileList.length; i++) {
          const file = fileList[i];
          const arrayBuffer = await file.arrayBuffer();
          const data = new Uint8Array(arrayBuffer);
          files.push({ name: file.name, data });
        }
        
        if (files.length === 1) {
          const fileData = createSafeBuffer(files[0].data);
          setFile({ ...files[0], data: fileData });
          setBuffers(fileData);
          setPageIndex(0);
          setIsFirstLoad(true); // Reset first load flag for new file
        } else {
          const merged = await mergePdfs(files.map(f => f.data));
          const name = files.map(f => f.name).join("+") + ".pdf";
          const mergedData = createSafeBuffer(merged);
          const combined: OpenedFile = { name, data: mergedData };
          setFile(combined);
          setBuffers(mergedData);
          setPageIndex(0);
          setIsFirstLoad(true); // Reset first load flag for new file
        }
      };
      input.click();
    }
  };

  const save = async () => {
    console.log("Save button clicked, buffers:", buffers?.length, "file:", file?.name);
    if (!buffers || !file) {
      showNotification("No document to save");
      return;
    }
    
    try {
      // Get current buffer state with all changes
      let workingData: Uint8Array;
      try {
        const testSlice = buffers.slice(0, 1);
        workingData = new Uint8Array(buffers);
        console.log("Using current buffers for save");
      } catch (e) {
        console.warn("Main buffers detached, using cached buffer");
        if (!cachedBuffer) {
          showNotification("No working buffer available. Please reload the document.");
          return;
        }
        workingData = new Uint8Array(cachedBuffer);
      }

      if (window.electronAPI && file.path) {
        // Electron mode - overwrite original file if it has a path
        try {
          const saved = await savePdfFile(file.name, workingData);
          if (saved) {
            console.log("File saved successfully to:", saved);
            showNotification("File saved successfully!");
            // Update file path in case it changed
            const updatedFile: OpenedFile = {
              ...file,
              path: saved,
              data: workingData
            };
            setFile(updatedFile);
          }
        } catch (error) {
          console.error("Error saving file:", error);
          showNotification("Error saving file: " + (error instanceof Error ? error.message : String(error)));
        }
      } else {
        // Browser mode or no original path - use Save As behavior
        await saveAs();
      }
    } catch (error) {
      console.error("Error saving file:", error);
      showNotification("Error saving file: " + (error instanceof Error ? error.message : String(error)));
    }
  };

  const saveAs = async () => {
    console.log("Save As button clicked, buffers:", buffers?.length, "file:", file?.name);
    if (!buffers || !file) {
      showNotification("No document to save");
      return;
    }
    
    try {
      // Get current buffer state with all changes
      let workingData: Uint8Array;
      try {
        const testSlice = buffers.slice(0, 1);
        workingData = new Uint8Array(buffers);
        console.log("Using current buffers for save as");
      } catch (e) {
        console.warn("Main buffers detached, using cached buffer");
        if (!cachedBuffer) {
          showNotification("No working buffer available. Please reload the document.");
          return;
        }
        workingData = new Uint8Array(cachedBuffer);
      }

      const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
      const baseName = file.name.replace(/\.pdf$/i, "");
      const suggestedName = `${baseName}_edited_${timestamp}.pdf`;

      if (window.electronAPI) {
        // Electron mode - use native save dialog
        const saved = await savePdfFile(suggestedName, workingData);
        if (saved) {
          console.log("File saved as:", saved);
          showNotification("File saved successfully!");
          await showInFolder(saved);
        }
      } else {
        // Browser mode - download the file
        const blob = new Blob([new Uint8Array(workingData)], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = suggestedName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        console.log("File downloaded as:", suggestedName);
        showNotification("File downloaded successfully!");
      }
    } catch (error) {
      console.error("Error saving file as:", error);
      showNotification("Error saving file: " + (error instanceof Error ? error.message : String(error)));
    }
  };

  const newDoc = async () => {
    console.log("New document button clicked");
    try {
      const blank = await insertBlankPage(new Uint8Array(), 0).catch(async () => {
        const a4 = await (await import("pdf-lib")).PDFDocument.create();
        a4.addPage([595, 842]);
        return a4.save();
      });
      const nf: OpenedFile = { name: "Untitled.pdf", data: blank };
      setFile(nf);
      setBuffers(blank);
      console.log("New document created successfully");
    } catch (error) {
      console.error("Error creating new document:", error);
    }
  };

  const onMerge = async () => {
    console.log("Merge button clicked, current buffers:", buffers?.length, "bytes");
    if (!buffers) {
      console.error("No current document to merge with");
      showNotification("Please open a document first before merging");
      return;
    }
    
    try {
      if (window.electronAPI) {
        // Electron mode
        console.log("Using Electron file dialog for merge");
        const files = await openPdfFiles();
        if (!files || files.length === 0) {
          console.log("No files selected for merge");
          return;
        }
        console.log("Selected files for merge:", files.map(f => f.name));
        const merged = await mergePdfs([buffers, ...files.map(f => f.data)]);
        console.log("Merge completed, new size:", merged.length, "bytes");
        
        // Create completely new file object to trigger hook update
        const newFileName = (file?.name?.replace(/\.pdf$/i, "") || "Document") + "_merged.pdf";
        const newFile: OpenedFile = { 
          name: newFileName, 
          data: merged 
        };
        
        setBuffers(merged);
        setFile(newFile);
        // Don't reset page index - stay on current page
        console.log("File state updated with merged document");
        showNotification(`Successfully merged ${files.length} file(s) with current document`);
      } else {
        // Browser mode
        console.log("Using browser file input for merge");
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".pdf";
        input.multiple = true;
        input.onchange = async (e) => {
          const fileList = (e.target as HTMLInputElement).files;
          if (!fileList || fileList.length === 0) {
            console.log("No files selected for merge");
            return;
          }
          
          try {
            console.log("Processing", fileList.length, "files for merge");
            const files: OpenedFile[] = [];
            for (let i = 0; i < fileList.length; i++) {
              const file = fileList[i];
              console.log("Reading file:", file.name);
              const arrayBuffer = await file.arrayBuffer();
              const data = new Uint8Array(arrayBuffer);
              files.push({ name: file.name, data });
            }
            
            console.log("Starting merge process...");
            const merged = await mergePdfs([buffers, ...files.map(f => f.data)]);
            console.log("Merge completed, new size:", merged.length, "bytes");
            
            // Create completely new file object to trigger hook update
            const newFileName = (file?.name?.replace(/\.pdf$/i, "") || "Document") + "_merged.pdf";
            const newFile: OpenedFile = { 
              name: newFileName, 
              data: merged 
            };
            
            setBuffers(merged);
            setFile(newFile);
            // Don't reset page index - stay on current page
            console.log("File state updated with merged document");
            showNotification(`Successfully merged ${files.length} file(s) with current document`);
          } catch (error) {
            console.error("Error during merge process:", error);
            showNotification("Error merging files: " + (error instanceof Error ? error.message : String(error)));
          }
        };
        input.click();
      }
    } catch (error) {
      console.error("Error in merge function:", error);
      showNotification("Error during merge: " + (error instanceof Error ? error.message : String(error)));
    }
  };

  const onExtract = async () => {
    console.log("Extract button clicked, buffers:", buffers?.length, "bytes");
    
    if (!buffers) {
      showNotification("Please open a document first");
      return;
    }
    
    try {
      console.log(`Extracting page ${pageIndex + 1}`);
      
      // Create a fresh working copy
      let workingData: Uint8Array;
      try {
        const testSlice = buffers.slice(0, 1);
        workingData = new Uint8Array(buffers);
        console.log("Created fresh copy for extraction");
      } catch (e) {
        console.warn("Main buffers detached, using cached buffer");
        if (!cachedBuffer) {
          showNotification("No working buffer available. Please reload the document.");
          return;
        }
        workingData = new Uint8Array(cachedBuffer);
      }
      
      const extracted = await extractPages(workingData, [pageIndex]);
      console.log("Extraction completed, extracted size:", extracted.length);
      
      if (window.electronAPI) {
        // Electron mode - use native save dialog
        const saved = await savePdfFile(`page-${pageIndex + 1}.pdf`, extracted);
        if (saved) await showInFolder(saved);
      } else {
        // Browser mode - download the file
        const blob = new Blob([new Uint8Array(extracted)], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `page-${pageIndex + 1}.pdf`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        console.log("Page extracted and downloaded successfully");
      }
      showNotification(`Page ${pageIndex + 1} extracted successfully`);
    } catch (error) {
      console.error("Error extracting page:", error);
      showNotification("Error extracting page: " + (error instanceof Error ? error.message : String(error)));
    }
  };

  const onRotate = async (degrees: number = 90) => {
    console.log("Rotate button clicked, degrees:", degrees, "buffers:", buffers?.length, "bytes");
    
    if (!buffers) {
      showNotification("No document loaded");
      return;
    }

    const currentPage = pageIndex; // Store current page to preserve it
    
    try {
      console.log(`Rotating page ${pageIndex + 1} by ${degrees} degrees`);
      
      // Always create a safe working copy from current buffers
      // Don't rely on cached buffers to avoid detachment issues
      let workingData: Uint8Array;
      try {
        // Test if main buffers is accessible
        const testSlice = buffers.slice(0, 1);
        workingData = new Uint8Array(buffers); // Create fresh copy immediately
        console.log("Created fresh copy from current buffers state");
      } catch (e) {
        console.warn("Main buffers detached, using cached buffer");
        const cachedData = cachedBuffer;
        if (!cachedData) {
          showNotification("No working buffer available. Please reload the document.");
          return;
        }
        try {
          cachedData.slice(0, 1); // Test cached buffer
          workingData = new Uint8Array(cachedData); // Create fresh copy
          console.log("Created fresh copy from cached buffer");
        } catch (cacheError) {
          showNotification("All buffers are corrupted. Please reload the document.");
          return;
        }
      }
      
      console.log("Working with buffer of size:", workingData.length);
      
      const out = await rotatePage(workingData, pageIndex, degrees);
      console.log("Rotation completed, new buffer size:", out.length);
      
      // Validate the output buffer
      if (!(out instanceof Uint8Array) || out.length === 0) {
        throw new Error("Invalid output from rotation");
      }
      
      // Create a completely fresh copy for state updates
      const finalBuffer = new Uint8Array(out);
      
      // Update both buffers and cache immediately
      setBuffers(finalBuffer);
      setCachedBuffer(finalBuffer);
      
      // Update file with the rotated data
      const updatedFile: OpenedFile = {
        ...file!,
        data: finalBuffer
      };
      setFile(updatedFile);

      // Preserve the current page after rotation
      setPageIndex(currentPage);
      
      const direction = degrees > 0 ? "clockwise" : "counter-clockwise";
      console.log("PDF state updated with rotated document, all buffers refreshed");
      showNotification(`Page ${pageIndex + 1} rotated ${Math.abs(degrees)}Â° ${direction} successfully`);
    } catch (error) {
      console.error("Error rotating page:", error);
      showNotification("Error rotating page: " + (error instanceof Error ? error.message : String(error)));
    }
  };

  // Refresh function to reload the current file
  const onRefresh = async () => {
    if (!file || !file.path) {
      showNotification("No file path available to refresh. Please open a file first.");
      return;
    }
    
    try {
      console.log("Refreshing file:", file.path);
      
      if (window.electronAPI) {
        // Electron mode - read from file system
        const data = await window.electronAPI.readFileAsUint8Array(file.path);
        if (!data) {
          throw new Error("Failed to read file data");
        }
        
        const refreshedFile: OpenedFile = {
          name: file.name,
          path: file.path,
          data: data
        };
        
        const freshBuffer = new Uint8Array(data);
        const currentPage = pageIndex; // Store current page
        setFile(refreshedFile);
        setBuffers(freshBuffer);
        setCachedBuffer(freshBuffer);
        setPageIndex(currentPage); // Restore current page
        setIsFirstLoad(true);
        
        console.log("File refreshed successfully from file system");
        showNotification("File refreshed successfully. All changes have been reset.");
      } else {
        showNotification("Refresh is only available in desktop mode. Please reopen the file manually.");
      }
    } catch (error) {
      console.error("Error refreshing file:", error);
      showNotification("Error refreshing file: " + (error instanceof Error ? error.message : String(error)));
    }
  };

  // Fit to page function
  const fitToPage = async () => {
    if (!pdf || !viewerRef.current) return;
    
    try {
      // Get page dimensions
      const page = await pdf.getPage(pageIndex + 1);
      const viewport = page.getViewport({ scale: 1 });
      
      // Get viewer container dimensions
      const viewerRect = viewerRef.current.getBoundingClientRect();
      const availableWidth = viewerRect.width - 40; // Account for padding
      const availableHeight = viewerRect.height - 40;
      
      // Calculate scale to fit
      const scaleX = availableWidth / viewport.width;
      const scaleY = availableHeight / viewport.height;
      const scale = Math.min(scaleX, scaleY, 2.0); // Cap at 2x
      
      setZoom(Math.max(0.1, scale));
    } catch (error) {
      console.error("Error fitting to page:", error);
    }
  };

  // Scroll to specific page in continuous mode
  const scrollToPage = (targetPageIndex: number) => {
    if (scrollMode !== 'continuous' || !viewerRef.current) {
      setPageIndex(targetPageIndex);
      return;
    }
    
    const container = viewerRef.current;
    const targetPage = container.querySelector(`[data-page-index="${targetPageIndex}"]`);
    
    if (targetPage) {
      targetPage.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'center' 
      });
      setPageIndex(targetPageIndex);
    }
  };

  // Effect for fit-to-page on first load
  useEffect(() => {
    if (pdf && isFirstLoad && viewerRef.current) {
      const timer = setTimeout(() => {
        fitToPage();
        setIsFirstLoad(false);
      }, 500); // Wait for layout to stabilize
      
      return () => clearTimeout(timer);
    }
  }, [pdf, isFirstLoad]);

  // Update viewer dimensions on resize
  useEffect(() => {
    const updateDimensions = () => {
      if (viewerRef.current) {
        const rect = viewerRef.current.getBoundingClientRect();
        setViewerDimensions({ width: rect.width, height: rect.height });
      }
    };

    updateDimensions();
    window.addEventListener('resize', updateDimensions);
    return () => window.removeEventListener('resize', updateDimensions);
  }, []);

  // Scroll listener for continuous mode to update page index
  useEffect(() => {
    if (scrollMode !== 'continuous' || !viewerRef.current) return;

    const handleScroll = () => {
      if (!viewerRef.current) return;
      
      const container = viewerRef.current;
      const pages = container.querySelectorAll('[data-page-index]');
      
      if (pages.length === 0) return;
      
      const containerRect = container.getBoundingClientRect();
      const containerCenter = containerRect.top + containerRect.height / 2;
      
      let closestPage = 0;
      let closestDistance = Infinity;
      
      pages.forEach((page, index) => {
        const pageRect = page.getBoundingClientRect();
        const pageCenter = pageRect.top + pageRect.height / 2;
        const distance = Math.abs(pageCenter - containerCenter);
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestPage = index;
        }
      });
      
      if (closestPage !== pageIndex) {
        setPageIndex(closestPage);
      }
    };

    const container = viewerRef.current;
    container.addEventListener('scroll', handleScroll, { passive: true });
    
    return () => {
      container.removeEventListener('scroll', handleScroll);
    };
  }, [scrollMode, pageIndex, pageCount]);

  const onPrint = async () => {
    if (!pdf || !file) {
      showNotification("Please open a document first");
      return;
    }

    try {
      console.log("Print function started");
      
      // Get current buffers state (includes all changes like rotations)
      let workingData: Uint8Array;
      try {
        if (!buffers) {
          showNotification("No PDF data available for printing");
          return;
        }
        buffers.slice(0, 1); // Test if detached
        workingData = buffers;
        console.log("Using current buffers state for printing");
      } catch (e) {
        console.warn("Main buffers detached, falling back to cached buffer");
        const cachedData = getWorkingBuffer();
        if (!cachedData) {
          showNotification("Cannot access PDF data for printing. Please reload the document.");
          return;
        }
        workingData = cachedData;
      }

      // Create a safe copy for printing
      const printBuffer = createSafeBuffer(workingData);
      console.log("Created safe buffer for printing, size:", printBuffer.length);

      if (window.electronAPI) {
        // Electron mode - use native print dialog
        console.log("Electron print mode - using native print");
        
        try {
          await window.electronAPI.printPdf(new Uint8Array(printBuffer), file.name);
          console.log("Native print dialog opened successfully");
        } catch (error) {
          console.error("Error with native print:", error);
          showNotification("Error opening print dialog: " + (error instanceof Error ? error.message : String(error)));
        }
      } else {
          console.log("Created PDF blob URL for printing");
          
          printWindow.document.write(`
            <html>
              <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Print PDF - ${file.name}</title>
                <style>
                  * {
                    unicode-bidi: bidi-override;
                    direction: inherit;
                  }
                  body { 
                    margin: 0; 
                    padding: 0; 
                    background: #f0f0f0;
                    font-family: Arial, "David", "Tahoma", "Times New Roman", sans-serif;
                    unicode-bidi: plaintext;
                    text-align: start;
                  }
                  .container {
                    width: 100%;
                    height: 100vh;
                    display: flex;
                    flex-direction: column;
                  }
                  .toolbar {
                    background: #333;
                    color: white;
                    padding: 10px;
                    text-align: center;
                    direction: ltr;
                  }
                  .toolbar button {
                    background: #007bff;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    margin: 0 5px;
                    border-radius: 4px;
                    cursor: pointer;
                  }
                  .toolbar button:hover {
                    background: #0056b3;
                  }
                  iframe { 
                    flex: 1;
                    border: none; 
                    width: 100%;
                    unicode-bidi: plaintext;
                  }
                  /* Hebrew text support */
                  .rtl-support {
                    direction: rtl;
                    text-align: right;
                    unicode-bidi: embed;
                  }
                </style>
              </head>
              <body>
                <div class="container">
                  <div class="toolbar">
                    <span>Print Preview - ${file.name}</span>
                    <button onclick="window.print()">Print PDF</button>
                    <button onclick="window.close()">Close</button>
                  </div>
                  <iframe src="${pdfUrl}" id="pdfFrame"></iframe>
                </div>
                <script>
                  // Set document direction and encoding for Hebrew support
                  document.documentElement.setAttribute('dir', 'auto');
                  document.documentElement.setAttribute('lang', 'he');
                  document.charset = 'UTF-8';
                  
                  document.getElementById('pdfFrame').onload = function() {
                    console.log('PDF loaded in iframe');
                    
                    // Try to set proper encoding and direction for the iframe content
                    try {
                      const iframeDoc = document.getElementById('pdfFrame').contentDocument;
                      if (iframeDoc) {
                        iframeDoc.documentElement.setAttribute('dir', 'auto');
                        iframeDoc.documentElement.setAttribute('lang', 'he');
                        const meta = iframeDoc.createElement('meta');
                        meta.setAttribute('charset', 'UTF-8');
                        if (iframeDoc.head) {
                          iframeDoc.head.appendChild(meta);
                        }
                      }
                    } catch (e) {
                      console.log('Could not modify iframe content for Hebrew support:', e);
                    }
                  };
                  
                  // Auto-focus the iframe for better print handling
                  setTimeout(function() {
                    document.getElementById('pdfFrame').contentWindow.focus();
                  }, 1000);
                </script>
              </body>
            </html>
          `);
          printWindow.document.close();
          
          // Clean up the blob URL after some time
          setTimeout(() => {
            URL.revokeObjectURL(pdfUrl);
          }, 60000);
          
        } catch (error) {
          console.error("Error creating PDF blob for printing:", error);
          printWindow.close();
          showNotification("Error preparing PDF for printing: " + (error instanceof Error ? error.message : String(error)));
        }
      } else {
        // Browser mode - create printable version with all pages rendered from current state
        console.log("Browser print mode");
        const printWindow = window.open('', '_blank', 'width=800,height=600');
        if (!printWindow) {
          showNotification("Could not open print window. Please check your popup blocker.");
          return;
        }

        // First, reload the PDF from current buffer to ensure we have all changes
        let currentPdf;
        try {
          const { getDocument } = await import("pdfjs-dist");
          currentPdf = await getDocument({ data: printBuffer }).promise;
          console.log("Reloaded PDF from current buffer for printing");
        } catch (error) {
          console.error("Error reloading PDF for printing:", error);
          showNotification("Error preparing PDF for printing: " + (error instanceof Error ? error.message : String(error)));
          printWindow.close();
          return;
        }

        printWindow.document.write(`
          <html>
            <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Print PDF - ${file.name}</title>
              <style>
                * {
                  unicode-bidi: bidi-override;
                  direction: inherit;
                }
                @media print {
                  body { 
                    margin: 0; 
                    font-family: Arial, "David", "Tahoma", "Times New Roman", sans-serif;
                    unicode-bidi: plaintext;
                  }
                  .page { 
                    page-break-after: always; 
                    display: flex; 
                    justify-content: center; 
                    align-items: center;
                    min-height: 100vh;
                    direction: ltr; /* Canvas content is always LTR */
                  }
                  .page:last-child { page-break-after: avoid; }
                  canvas { 
                    max-width: 100%; 
                    max-height: 100vh; 
                    object-fit: contain;
                  }
                }
                @media screen {
                  body { 
                    margin: 20px; 
                    font-family: Arial, "David", "Tahoma", "Times New Roman", sans-serif;
                    unicode-bidi: plaintext;
                  }
                  .page { margin-bottom: 20px; text-align: center; }
                  canvas { border: 1px solid #ccc; margin: 10px 0; }
                  .loading { padding: 20px; }
                }
              </style>
            </head>
            <body>
              <div class="loading">Preparing PDF for printing...</div>
            </body>
          </html>
        `);

        // Render all pages to canvases for printing using current PDF state
        const renderAllPages = async () => {
          const container = printWindow.document.body;
          container.innerHTML = '';

          const currentPageCount = currentPdf.numPages;
          console.log(`Rendering ${currentPageCount} pages for printing`);

          for (let i = 0; i < currentPageCount; i++) {
            try {
              const pageDiv = printWindow.document.createElement('div');
              pageDiv.className = 'page';
              
              const canvas = printWindow.document.createElement('canvas');
              const page = await currentPdf.getPage(i + 1);
              
              // Use a higher resolution for printing
              const viewport = page.getViewport({ scale: 2.0 });
              canvas.width = viewport.width;
              canvas.height = viewport.height;
              
              const context = canvas.getContext('2d');
              if (context) {
                await page.render({
                  canvasContext: context,
                  viewport: viewport
                }).promise;
              }
              
              pageDiv.appendChild(canvas);
              container.appendChild(pageDiv);
              console.log(`Rendered page ${i + 1} for printing`);
            } catch (error) {
              console.error(`Error rendering page ${i + 1} for print:`, error);
              const errorDiv = printWindow.document.createElement('div');
              errorDiv.textContent = `Error rendering page ${i + 1}`;
              container.appendChild(errorDiv);
            }
          }

          // Add print button and auto-print
          const printBtn = printWindow.document.createElement('button');
          printBtn.textContent = 'Print PDF';
          printBtn.style.cssText = 'position: fixed; top: 10px; right: 10px; padding: 10px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; z-index: 1000;';
          printBtn.onclick = () => printWindow.print();
          container.appendChild(printBtn);

          console.log("All pages rendered for printing, showing print dialog");
          // Auto-print after a short delay
          setTimeout(() => {
            printWindow.print();
          }, 1000);
        };

        renderAllPages().catch(error => {
          console.error("Error preparing print:", error);
          printWindow.document.body.innerHTML = `<p>Error preparing PDF for printing: ${error.message}</p>`;
        });
      }
    } catch (error) {
      console.error("Error in print function:", error);
      showNotification("Error preparing document for printing: " + (error instanceof Error ? error.message : String(error)));
    }
  };

  const onSearch = async (query: string) => {
    if (!pdf) return;
    const rects = await extractTextRects(pdf, pageIndex, query);
    const canvas = document.querySelector<HTMLCanvasElement>("#pageCanvas");
    if (!canvas) return;
    const ctx = canvas.getContext("2d")!;
    await renderPageToCanvas(pdf, pageIndex, zoom, canvas);
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "yellow";
    for (const r of rects) {
      ctx.fillRect(r.x, canvas.height - r.y - r.h, r.w, r.h);
    }
    ctx.restore();
  };

  const onInkStroke = async (pts: {x:number;y:number}[]) => {
    const workingBuffer = getWorkingBuffer();
    if (!workingBuffer) return;
    
    try {
      const freshBuffer = createSafeBuffer(workingBuffer);
      const out = await addInkPath(freshBuffer, pageIndex, pts, 2);
      const outCopy = createSafeBuffer(out);
      
      // Update state in a single batch to prevent unnecessary re-renders
      React.startTransition(() => {
        setBuffers(outCopy);
        setFile(prev => prev ? { ...prev, data: outCopy } : prev as any);
      });
    } catch (error) {
      console.error("Error in ink stroke:", error);
    }
  };

  // Mouse wheel handler for page navigation and zoom
  const handleWheel = (e: React.WheelEvent) => {
    if (!pdf) return;
    
    // Check if Ctrl key is held (zoom mode)
    if (e.ctrlKey) {
      e.preventDefault();
      const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
      const newZoom = Math.max(0.1, Math.min(5.0, zoom + zoomDelta));
      setZoom(newZoom);
      return;
    }
    
    // Handle scrolling based on mode
    if (scrollMode === 'page') {
      // Page-by-page scrolling (prevent default)
      e.preventDefault();
      
      if (pageCount <= 1) return;
      
      // Check if wheel is scrolling vertically
      if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
        if (e.deltaY > 0) {
          // Scrolling down - go to next page
          if (pageIndex < pageCount - 1) {
            setPageIndex(pageIndex + 1);
          }
        } else {
          // Scrolling up - go to previous page
          if (pageIndex > 0) {
            setPageIndex(pageIndex - 1);
          }
        }
      }
    }
    // For continuous mode, don't prevent default - allow natural scrolling
  };

  // Keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Handle Ctrl+P for print
      if (e.ctrlKey && e.key === 'p') {
        e.preventDefault();
        onPrint();
        return;
      }
      
      if (!pdf || pageCount <= 1) return;
      
      switch (e.key) {
        case 'ArrowUp':
        case 'ArrowLeft':
          e.preventDefault();
          if (scrollMode === 'page') {
            if (pageIndex > 0) {
              setPageIndex(pageIndex - 1);
            }
          } else {
            // Continuous mode - scroll to previous page
            scrollToPage(Math.max(0, pageIndex - 1));
          }
          break;
        case 'ArrowDown':
        case 'ArrowRight':
          e.preventDefault();
          if (scrollMode === 'page') {
            if (pageIndex < pageCount - 1) {
              setPageIndex(pageIndex + 1);
            }
          } else {
            // Continuous mode - scroll to next page
            scrollToPage(Math.min(pageCount - 1, pageIndex + 1));
          }
          break;
        case 'Home':
          e.preventDefault();
          if (scrollMode === 'page') {
            setPageIndex(0);
          } else {
            scrollToPage(0);
          }
          break;
        case 'End':
          e.preventDefault();
          if (scrollMode === 'page') {
            setPageIndex(pageCount - 1);
          } else {
            scrollToPage(pageCount - 1);
          }
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [pdf, pageCount, pageIndex, scrollMode]);

  const addText = async () => {
    console.log("Add text button clicked");
    setShowTextDialog(true);
  };

  const handleAddText = async () => {
    const workingBuffer = getWorkingBuffer();
    if (!workingBuffer || !textInput.trim()) return;
    
    try {
      const freshBuffer = createSafeBuffer(workingBuffer);
      const out = await (await import("./lib/pdfWrite")).addTextBox(freshBuffer, pageIndex, textInput.trim(), 72, 72);
      const outCopy = createSafeBuffer(out);
      setBuffers(outCopy);
      setFile(prev => prev ? { ...prev, data: outCopy } : prev as any);
      setTextInput("");
      setShowTextDialog(false);
    } catch (error) {
      console.error("Error adding text:", error);
    }
  };

  const highlightSelection = async () => {
    console.log("Highlight button clicked");
    setShowHighlightDialog(true);
  };

  const handleHighlight = async () => {
    const workingBuffer = getWorkingBuffer();
    if (!pdf || !workingBuffer || !highlightInput.trim()) return;
    
    try {
      const rects = await extractTextRects(pdf, pageIndex, highlightInput.trim());
      const freshBuffer = createSafeBuffer(workingBuffer);
      const out = await (await import("./lib/pdfWrite")).addHighlightRects(freshBuffer, pageIndex, rects);
      const outCopy = createSafeBuffer(out);
      setBuffers(outCopy);
      setFile(prev => prev ? { ...prev, data: outCopy } : prev as any);
      setHighlightInput("");
      setShowHighlightDialog(false);
    } catch (error) {
      console.error("Error highlighting text:", error);
    }
  };

  // --- New: OCR, signature image, redaction raster ---
  const doOCRCurrentPage = async () => {
    console.log("OCR button clicked");
    if (!pdf || !buffers) {
      alert("Please open a document first");
      return;
    }
    
    try {
      console.log(`Starting OCR for page ${pageIndex + 1}`);
      alert("OCR started. This may take a few moments...");
      
      const canvas = document.createElement("canvas");
      await renderPageToCanvas(pdf, pageIndex, 2, canvas);
      console.log("Page rendered to canvas for OCR");
      
      const { ocrCanvas } = await import("./lib/ocr");
      console.log("OCR library loaded, starting text recognition...");
      const words = await ocrCanvas(canvas, "eng");
      console.log(`OCR completed, found ${words.length} words`);
      
      // Use current buffers state (includes all previous changes)
      let workingData: Uint8Array;
      try {
        const testSlice = buffers.slice(0, 1);
        workingData = new Uint8Array(buffers);
        console.log("Created fresh copy for OCR");
      } catch (e) {
        console.warn("Main buffers detached, using cached buffer");
        if (!cachedBuffer) {
          alert("No working buffer available. Please reload the document.");
          return;
        }
        workingData = new Uint8Array(cachedBuffer);
      }
      
      const { PDFDocument, StandardFonts } = await import("pdf-lib");
      const doc = await PDFDocument.load(workingData);
      const font = await doc.embedFont(StandardFonts.Helvetica);
      const page = doc.getPage(pageIndex);
      
      let addedWords = 0;
      for (const w of words) {
        if (!w.text) continue;
        const size = Math.max(8, w.h / 1.2);
        page.drawText(w.text, { x: w.x, y: w.y, size, font, opacity: 0 });
        addedWords++;
      }
      
      const out = await doc.save();
      const finalBuffer = new Uint8Array(out);
      
      setBuffers(finalBuffer);
      setCachedBuffer(finalBuffer);
      setFile(prev => prev ? { ...prev, data: finalBuffer } : prev as any);
      
      console.log(`OCR completed successfully, added ${addedWords} text elements`);
      alert(`OCR completed for page ${pageIndex + 1}. Found ${addedWords} text elements.`);
    } catch (error) {
      console.error("Error during OCR:", error);
      alert("Error during OCR: " + (error instanceof Error ? error.message : String(error)));
    }
  };

  const doSignature = async () => {
    console.log("Signature button clicked");
    if (!buffers) {
      alert("Please open a document first");
      return;
    }
    
    try {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/png,image/jpeg";
      input.onchange = async () => {
        const f = (input.files && input.files[0]);
        if (!f) return;
        
        try {
          console.log("Processing signature image:", f.name);
          const arr = new Uint8Array(await f.arrayBuffer());
          const { placeSignatureImage } = await import("./lib/signature");
          
          const workingBuffer = getWorkingBuffer();
          if (!workingBuffer) {
            alert("Buffer is corrupted. Please reload the document.");
            return;
          }
          
          const freshBuffer = createSafeBuffer(workingBuffer);
          const out = await placeSignatureImage(freshBuffer, pageIndex, arr, 72, 72, 200, 80);
          const outCopy = createSafeBuffer(out);
          setBuffers(outCopy);
          setFile(prev => prev ? { ...prev, data: outCopy } : prev as any);
          console.log("Signature added successfully");
          alert("Signature added successfully");
        } catch (error) {
          console.error("Error adding signature:", error);
          alert("Error adding signature: " + (error instanceof Error ? error.message : String(error)));
        }
      };
      input.click();
    } catch (error) {
      console.error("Error in signature function:", error);
      alert("Error: " + (error instanceof Error ? error.message : String(error)));
    }
  };

  const doRedactBox = async () => {
    console.log("Redact button clicked");
    if (!pdf || !buffers) {
      alert("Please open a document first");
      return;
    }
    setShowRedactDialog(true);
  };

  const handleRedact = async () => {
    if (!pdf || !buffers || !redactInput.trim()) return;
    
    try {
      console.log("Processing redaction with input:", redactInput);
      const [x, y, w, h] = redactInput.split(",").map(s => parseFloat(s.trim()));
      
      if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h)) {
        alert("Invalid format. Please use: x,y,width,height (e.g., 100,100,200,60)");
        return;
      }
      
      console.log(`Redacting area: x=${x}, y=${y}, w=${w}, h=${h}`);
      
      // Use current buffers state (includes all previous changes)
      let workingData: Uint8Array;
      try {
        const testSlice = buffers.slice(0, 1);
        workingData = new Uint8Array(buffers);
        console.log("Created fresh copy for redaction");
      } catch (e) {
        console.warn("Main buffers detached, using cached buffer");
        if (!cachedBuffer) {
          alert("No working buffer available. Please reload the document.");
          return;
        }
        workingData = new Uint8Array(cachedBuffer);
      }
      
      const { redactByRasterize } = await import("./lib/redact");
      const out = await redactByRasterize(workingData, pdf as any, pageIndex, 2, [{ x, y, w, h }]);
      
      const finalBuffer = new Uint8Array(out);
      setBuffers(finalBuffer);
      setCachedBuffer(finalBuffer);
      setFile(prev => prev ? { ...prev, data: finalBuffer } : prev as any);
      setRedactInput("");
      setShowRedactDialog(false);
      
      console.log("Redaction completed successfully");
      alert(`Redaction completed for page ${pageIndex + 1}`);
    } catch (error) {
      console.error("Error during redaction:", error);
      alert("Error during redaction: " + (error instanceof Error ? error.message : String(error)));
    }
  };

  return (
    <div className="h-screen flex flex-col bg-gray-50">
      {/* Main Toolbar */}
      <div className="bg-white border-b border-gray-200 shadow-sm">
        <div className="flex items-center justify-between px-4 py-2">
          {/* Left: File operations */}
          <div className="flex items-center space-x-2">
            <button 
              onClick={open}
              className="flex items-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
              </svg>
              <span>Open</span>
            </button>
            <button 
              onClick={save}
              className="flex items-center space-x-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3-3m0 0l-3 3m3-3v12" />
              </svg>
              <span>Save</span>
            </button>
            <button 
              onClick={saveAs}
              className="flex items-center space-x-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3-3m0 0l-3 3m3-3v12" />
              </svg>
              <span>Save As</span>
            </button>
            <div className="h-6 w-px bg-gray-300 mx-2"></div>
            <button 
              onClick={newDoc}
              className="px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-lg transition-colors"
            >
              New
            </button>
            <button 
              onClick={onMerge}
              className="px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-lg transition-colors"
            >
              Merge
            </button>
            <button 
              onClick={onPrint}
              className="px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-lg transition-colors"
            >
              Print
            </button>
          </div>

          {/* Center: Document title */}
          <div className="flex-1 text-center">
            <h1 className="text-lg font-semibold text-gray-800">
              {file?.name || "PDFusion"}
            </h1>
          </div>

          {/* Right: Zoom controls */}
          <div className="flex items-center space-x-3">
            <button 
              onClick={() => setZoom(Math.max(0.25, zoom - 0.25))}
              className="p-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 12H4" />
              </svg>
            </button>
            <span className="text-sm font-medium text-gray-700 min-w-[60px] text-center">
              {Math.round(zoom * 100)}%
            </span>
            <button 
              onClick={() => setZoom(Math.min(3, zoom + 0.25))}
              className="p-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
              </svg>
            </button>
            <input 
              type="range" 
              min={0.25} 
              max={3} 
              step={0.25} 
              value={zoom}
              onChange={e => setZoom(parseFloat(e.target.value))}
              className="w-20 accent-blue-600"
            />
          </div>
        </div>
      </div>

      {/* Tools Toolbar */}
      <div className="bg-gray-100 border-b border-gray-200 px-4 py-2">
        <div className="flex items-center space-x-1">
          <ToolButton icon="cursor" label="Select" />
          <ToolButton icon="hand" label="Pan" />
          <ToolButton icon="text" label="Text" onClick={addText} />
          <ToolButton icon="marker" label="Highlight" onClick={highlightSelection} />
          <ToolButton icon="pen" label="Draw" />
          <ToolButton icon="signature" label="Sign" onClick={doSignature} />
          <div className="h-6 w-px bg-gray-300 mx-2"></div>
          <ToolButton icon="rotateLeft" label="Rotate Left" onClick={() => onRotate(-90)} />
          <ToolButton icon="rotateRight" label="Rotate Right" onClick={() => onRotate(90)} />
          <ToolButton icon="extract" label="Extract" onClick={onExtract} />
          <ToolButton icon="ocr" label="OCR" onClick={doOCRCurrentPage} />
          <ToolButton icon="redact" label="Redact" onClick={doRedactBox} />
          <div className="h-6 w-px bg-gray-300 mx-2"></div>
          <ToolButton icon="refresh" label="Refresh" onClick={onRefresh} />
        </div>
      </div>

      {/* Main Content Area */}
      <div className="flex flex-1 min-h-0">
        {/* Left Panel - Page Thumbnails */}
        <div className="w-64 bg-white border-r border-gray-200 flex flex-col">
          <div className="p-3 border-b border-gray-200">
            <h3 className="text-sm font-semibold text-gray-800">Pages</h3>
          </div>
          <div className="flex-1 overflow-auto custom-scrollbar">
            {pageCount > 0 ? (
              <Sidebar pageCount={pageCount} current={pageIndex} onJump={setPageIndex} pdf={pdf} />
            ) : (
              <div className="p-4 text-center text-gray-500">
                <p className="text-sm">No pages to display</p>
              </div>
            )}
          </div>
        </div>

        {/* Main Document Viewer */}
        <div className="flex-1 flex flex-col bg-gray-100">
          {pdf ? (
            <>
              {/* Document Controls */}
              <div className="bg-white border-b border-gray-200 px-4 py-3">
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-3">
                    <button 
                      onClick={() => {
                        const newIndex = Math.max(0, pageIndex - 1);
                        scrollMode === 'continuous' ? scrollToPage(newIndex) : setPageIndex(newIndex);
                      }}
                      disabled={pageIndex === 0}
                      className="p-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                      </svg>
                    </button>
                    <div className="flex items-center space-x-2">
                      <span className="text-sm text-gray-600">Page</span>
                      <input 
                        type="number" 
                        min={1} 
                        max={pageCount} 
                        value={pageIndex + 1}
                        onChange={(e) => {
                          const newIndex = Math.max(0, Math.min(pageCount - 1, parseInt(e.target.value) - 1));
                          scrollMode === 'continuous' ? scrollToPage(newIndex) : setPageIndex(newIndex);
                        }}
                        className="w-16 px-2 py-1 text-sm border border-gray-300 rounded text-center"
                      />
                      <span className="text-sm text-gray-600">of {pageCount}</span>
                    </div>
                    <button 
                      onClick={() => {
                        const newIndex = Math.min(pageCount - 1, pageIndex + 1);
                        scrollMode === 'continuous' ? scrollToPage(newIndex) : setPageIndex(newIndex);
                      }}
                      disabled={pageIndex === pageCount - 1}
                      className="p-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                      </svg>
                    </button>
                    
                    {/* Zoom Controls */}
                    <div className="flex items-center space-x-2 border-l border-gray-300 pl-3">
                      <button 
                        onClick={() => setZoom(Math.max(0.1, zoom - 0.1))}
                        className="p-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
                        title="Zoom Out"
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7" />
                        </svg>
                      </button>
                      <div className="flex items-center space-x-1">
                        <span className="text-sm text-gray-600 min-w-12 text-center">{Math.round(zoom * 100)}%</span>
                      </div>
                      <button 
                        onClick={() => setZoom(Math.min(5.0, zoom + 0.1))}
                        className="p-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
                        title="Zoom In"
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7" />
                        </svg>
                      </button>
                      <button 
                        onClick={fitToPage}
                        className="p-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
                        title="Fit to Page"
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                        </svg>
                      </button>
                    </div>
                    
                    {/* Scroll Mode Toggle */}
                    <div className="flex items-center space-x-2 border-l border-gray-300 pl-3">
                      <button 
                        onClick={() => setScrollMode(scrollMode === 'page' ? 'continuous' : 'page')}
                        className={`p-2 rounded-lg transition-colors ${
                          scrollMode === 'page' 
                            ? 'bg-blue-100 text-blue-600' 
                            : 'text-gray-600 hover:bg-gray-100'
                        }`}
                        title={scrollMode === 'page' ? 'Switch to Continuous Scrolling' : 'Switch to Page-by-Page Scrolling'}
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          {scrollMode === 'page' ? (
                            // Page icon
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                          ) : (
                            // Continuous scroll icon (multiple pages)
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />
                          )}
                        </svg>
                      </button>
                      <span className="text-xs text-gray-500 hidden sm:block">
                        {scrollMode === 'page' ? 'Page' : 'Continuous'}
                      </span>
                    </div>
                  </div>
                  <SearchBox onSearch={onSearch} />
                </div>
              </div>

              {/* Document Canvas */}
              <div 
                ref={viewerRef}
                className="flex-1 overflow-auto p-6 custom-scrollbar"
                onWheel={handleWheel}
              >
                {scrollMode === 'page' ? (
                  // Single page mode
                  <div className="flex justify-center">
                    <div className="bg-white shadow-lg rounded-lg overflow-hidden document-shadow">
                      <PagePortal
                        key={(file?.name || 'doc') + pageIndex} // Force re-render when file changes
                        pdf={pdf}
                        pageIndex={pageIndex}
                        zoom={zoom}
                        onInkStroke={onInkStroke}
                      />
                    </div>
                  </div>
                ) : (
                  // Continuous scrolling mode
                  <div className="flex flex-col items-center space-y-4">
                    {Array.from({ length: pageCount }, (_, index) => (
                      <div 
                        key={`page-${index}`}
                        data-page-index={index}
                        className="bg-white shadow-lg rounded-lg overflow-hidden document-shadow"
                      >
                        <PagePortal
                          pdf={pdf}
                          pageIndex={index}
                          zoom={zoom}
                          onInkStroke={onInkStroke}
                        />
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </>
          ) : (
            <div className="flex-1 flex items-center justify-center">
              <div className="text-center">
                <div className="w-24 h-24 mx-auto mb-4 text-gray-400">
                  <svg fill="currentColor" viewBox="0 0 24 24">
                    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
                  </svg>
                </div>
                <h3 className="text-xl font-semibold text-gray-800 mb-2">Open a PDF Document</h3>
                <p className="text-gray-600 mb-6">Choose a PDF file to start viewing and editing</p>
                <button 
                  onClick={open}
                  className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                >
                  Browse Files
                </button>
              </div>
            </div>
          )}
        </div>
      </div>
      
      {/* Text Input Dialog */}
      {showTextDialog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl shadow-2xl p-6 w-96">
            <h3 className="text-lg font-semibold text-gray-800 mb-4">Add Text</h3>
            <input
              type="text"
              value={textInput}
              onChange={(e) => setTextInput(e.target.value)}
              placeholder="Enter text to add to the document"
              className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent mb-4"
              autoFocus
            />
            <div className="flex justify-end space-x-3">
              <button
                onClick={() => {setShowTextDialog(false); setTextInput("");}}
                className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={handleAddText}
                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
              >
                Add Text
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Highlight Input Dialog */}
      {showHighlightDialog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl shadow-2xl p-6 w-96">
            <h3 className="text-lg font-semibold text-gray-800 mb-4">Highlight Text</h3>
            <input
              type="text"
              value={highlightInput}
              onChange={(e) => setHighlightInput(e.target.value)}
              placeholder="Enter text to highlight"
              className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-yellow-500 focus:border-transparent mb-4"
              autoFocus
            />
            <div className="flex justify-end space-x-3">
              <button
                onClick={() => {setShowHighlightDialog(false); setHighlightInput("");}}
                className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={handleHighlight}
                className="px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 transition-colors"
              >
                Highlight
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Redact Input Dialog */}
      {showRedactDialog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl shadow-2xl p-6 w-96">
            <h3 className="text-lg font-semibold text-gray-800 mb-4">Redact Area</h3>
            <p className="text-sm text-gray-600 mb-3">
              Enter coordinates in format: x,y,width,height
            </p>
            <p className="text-xs text-gray-500 mb-4">
              Example: 100,100,200,60 (x=100, y=100, width=200, height=60)
            </p>
            <input
              type="text"
              value={redactInput}
              onChange={(e) => setRedactInput(e.target.value)}
              placeholder="100,100,200,60"
              className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent mb-4"
              autoFocus
            />
            <div className="flex justify-end space-x-3">
              <button
                onClick={() => {setShowRedactDialog(false); setRedactInput("");}}
                className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={handleRedact}
                className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors"
              >
                Redact
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Flying Notification */}
      {notification && (
        <div className="fixed top-4 right-4 z-50 bg-green-600 text-white px-6 py-3 rounded-lg shadow-lg animate-pulse">
          <div className="flex items-center space-x-2">
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
            </svg>
            <span>{notification}</span>
          </div>
        </div>
      )}
    </div>
  );
}

function PagePortal(props: {
  pdf: any; pageIndex: number; zoom: number; onInkStroke: (pts:{x:number;y:number}[]) => void;
}) {
  const ref = React.useRef<HTMLCanvasElement | null>(null);
  const renderingRef = React.useRef<boolean>(false);
  
  React.useEffect(() => {
    const run = async () => {
      if (!props.pdf || !ref.current || renderingRef.current) return;
      
      try {
        renderingRef.current = true;
        // Clear the canvas first
        const canvas = ref.current;
        const ctx = canvas.getContext("2d");
        if (ctx) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        await renderPageToCanvas(props.pdf, props.pageIndex, props.zoom, canvas);
      } catch (error) {
        console.error("Error rendering page:", error);
      } finally {
        renderingRef.current = false;
      }
    };
    
    // Add a small delay to prevent conflicts
    const timeoutId = setTimeout(run, 100);
    return () => clearTimeout(timeoutId);
  }, [props.pdf, props.pageIndex, props.zoom]);

  const drawing = React.useRef<{ pts: {x:number;y:number}[] } | null>(null);
  const toLocal = (e: React.MouseEvent) => {
    const rect = ref.current!.getBoundingClientRect();
    const canvas = ref.current!;
    // Convert screen coordinates to canvas coordinates
    const canvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
    const canvasY = (e.clientY - rect.top) * (canvas.height / rect.height);
    // Convert canvas coordinates to PDF coordinates (flip Y-axis for PDF)
    return { x: canvasX, y: canvas.height - canvasY };
  };

  const onDown = (e: React.MouseEvent) => {
    drawing.current = { pts: [toLocal(e)] };
  };
  const onMove = (e: React.MouseEvent) => {
    if (!drawing.current) return;
    drawing.current.pts.push(toLocal(e));
  };
  const onUp = () => {
    if (!drawing.current) return;
    props.onInkStroke(drawing.current.pts);
    drawing.current = null;
  };

  return (
    <canvas
      id="pageCanvas"
      ref={ref}
      className="block cursor-crosshair"
      onMouseDown={onDown}
      onMouseMove={onMove}
      onMouseUp={onUp}
      onMouseLeave={onUp}
    />
  );
}
